{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fprq2 System;}{\f3\fswiss MS Sans Serif;}}
{\colortbl\red0\green0\blue0;}
\deflang2057\pard\qc\plain\f3\fs24 Solid Shapes \plain\f3\fs16 
\par \pard\plain\f3\fs16 
\par You should now have a spinning cube (or somthing) on your screen. But its only a bunch of lines. What you really want it it to be a solid shape, isnt it.
\par 
\par Again, we're gonna have to change to way we store the shape, because you can't fill in a line. The shape will have to be stored as triangles, which we can fill in.
\par 
\par Acually, I lie. When I first made a solid file routine, I made it be able to fill in any convex shape, because I could then mahe a cube out of 6 squares instead of 12 triangles. I'm lazy like that.
\par 
\par (A conxex shape is a shape that only curves out, like a circle, square or triange, and dosn't have any sticky in bits, like an L shape, or a star)
\par 
\par Anyway, getting back to a polygon filler, considor that the screen is 200 rows high. That means that if you draw 200 lines ontop of each other, from left to right of the screen, you could fill in the whole screen. Have a look at my amazing pictures. If you can't see the triangle then blur your eyes slightly.
\par 
\par ********************    ********************    ********************
\par *                        *    *------------------------*    *                        *
\par *                        *    *------------------------*    *                        *
\par *                        *    *------------------------*    *      --                *
\par *                        *    *------------------------*    *      -----             *
\par *                        *    *------------------------*    *      ---------         *
\par *                        *    *------------------------*    *                        *
\par ********************    ********************    ********************
\par 
\par   An empty screen    A screen full of       A triangle made
\par                                         lines                   out of lines
\par  
\par 
\par Now you know what I'm on about, your wondering how make this into a program.
\par 
\par First, I'll show you have to change program above so that we can just call the sub routine with one line.
\par 
\par This program will draw a cube, still in wire frame, but it will store the cube one face at a time, and also allow you to store triangles, squares, and any other polygon all at the same time.
\par 
\par It may look alot more complicated, but really, it is doing the same thing alot of times.
\par All three rotations are used here, and are put in8to seperate routines that are called from the main loop. If you are using VB, the data thing don't work, so you'll have to
\par put the numbers in a seperate file and input the data from that file.
\par 
\par The one new feature here is that the original points are transfered into a tempory array before each frame is drawn. The numbers in this tempory array are then rotated.
\par 
\par This is very important, because if you use the same array, and keep rotating those points, each time you rotate them, they get more and more distorted.
\par 
\par ------------------------------ Source Code ---------------------------
\par 
\par 
\par face = 5
\par DIM lev(face, 26)
\par DIM temp(face, 26)
\par DIM ner(20, 2)
\par xofs = 160: yofs = 100: zeye = 800
\par pie = (22 / 7) * 18
\par 
\par DATA   4,1 , -50,50,-50,     50,50,-50,     50,-50,-50,  -50,-50,-50
\par DATA   4,2 , -50,-50,50,    50,-50,50,    50,50,50,     -50,50,50
\par DATA   4,3 , -50,-50,-50,   50,-50,-50,   50,-50,50,   -50,-50,502
\par DATA   4,4,  -50,50,-50 ,   -50,-50,-50,  -50,-50,50,   -50,50,50
\par DATA   4,5 ,  50,50,50,      50,-50,50,    50,-50,-50,   50,50,-50
\par 
\par FOR n = 1 TO face
\par   READ lev(n, 1): READ lev(n, 2)
\par     FOR m = 1 TO lev(n, 1) * 3
\par      READ lev(n, 2 + m)
\par    NEXT m
\par NEXT n
\par 
\par a2 = 7
\par 
\par MAINLOOP:
\par 
\par a1 = a1 + 5 / pie
\par a2 = a2 + 5 / pie
\par a3 = a3 + 5 / pie
\par 
\par ' Copy the numbers is the original shape into a tempory array, and then
\par ' rotate the tempary array.
\par 
\par FOR n% = 1 TO face: FOR m% = 1 TO 2 + lev(n%, 1) * 3
\par temp(n%, m%) = lev(n%, m%)
\par NEXT m%: NEXT n%
\par 
\par GOSUB rotate.x
\par GOSUB rotate.y
\par GOSUB Rotate.z
\par 
\par 
\par CLS
\par 
\par 
\par FOR fc% = 1 TO face
\par   poly = 4: 'lev(order(fc%, 1), 1)
\par   FOR n% = 1 TO poly
\par    X = temp(fc%, (n% * 3))
\par    Y = temp(fc%, 1 + (n% * 3))
\par    z = temp(fc%, 2 + (n% * 3))
\par    ner(n%, 1) = xofs + INT(X * (zeye / (zeye - z)))\
\

\par 
\par 
\par 
\par 
\par    ner(n%, 2) = yofs + INT(Y * (zeye / (zeye - z)))
\par   NEXT n%
\par   col = lev(order(fc%, 1), 2)
\par 
\par 
\par ' This bit will draw an outline of the shape, which is a HELL of a
\par ' lot faster than the filler routine.
\par 
\par ' As each row in the ner() array, contains a points in the polygon,
\par ' we have to draw a line between point 1 and point 2, point 2 and point 3,
\par ' and so on till the end, and then the end point to the beginning point.
\par 
\par ' Note that ner() is short for Corner(), but i'm to lazy to type Corner all
\par ' the time. I'll use this in just about all programs from now on.
\par 
\par   FOR n% = 1 TO poly
\par    IF n% = poly THEN
\par      LINE (ner(n%, 1), ner(n%, 2))-(ner(1, 1), ner(1, 2)), 15
\par     ELSE
\par      LINE (ner(n%, 1), ner(n%, 2))-(ner(n% + 1, 1), ner(n% + 1, 2)), 15
\par    END IF
\par   NEXT n%
\par 
\par 
\par ' This line, that will call the Polgon Filler, is blanked out, cos the
\par ' routine don't exist yet.
\par 
\par ' CALL DrawTri(ner(), col)
\par 
\par  'END IF
\par NEXT fc%
\par 
\par GOTO MAINLOOP
\par 
\par 
\par '****************
\par Rotate.z:
\par FOR cu = 1 TO face
\par  FOR m% = 3 TO (lev(cu, 1) * 3) STEP 3
\par   X = temp(cu, m%): Y = temp(cu, m% + 1): z = temp(cu, m% + 2)
\par   Xrotated = COS(a1) * X - SIN(a1) * Y
\par   Yrotated = SIN(a1) * X + COS(a1) * Y
\par   Zrotated = z
\par   temp(cu, m%) = Xrotated
\par   temp(cu, m% + 1) = Yrotated
\par   temp(cu, m% + 2) = Zrotated
\par  NEXT m%
\par NEXT cu
\par RETURN
\par '****************
\par rotate.y:
\par FOR cu = 1 TO face
\par  FOR m% = 3 TO (lev(cu, 1) * 3) STEP 3
\par   X = temp(cu, m%): Y = temp(cu, m% + 1): z = temp(cu, m% + 2)
\par   Xrotated = COS(a2) * X - SIN(a2) * z
\par   Yrotated = Y
\par   Zrotated = SIN(a2) * X + COS(a2) * z
\par   temp(cu, m%) = Xrotated
\par   temp(cu, m% + 1) = Yrotated
\par   temp(cu, m% + 2) = Zrotated
\par  NEXT m%
\par NEXT cu
\par RETURN
\par '****************
\par rotate.x:
\par FOR cu = 1 TO face
\par  FOR m% = 3 TO (lev(cu, 1) * 3) STEP 3
\par   X = temp(cu, m%): Y = temp(cu, m% + 1): z = temp(cu, m% + 2)
\par   Xrotated = X
\par   Yrotated = COS(a3) * Y - SIN(a3) * z
\par   Zrotated = SIN(a3) * Y + COS(a3) * z
\par   temp(cu, m%) = Xrotated
\par   temp(cu, m% + 1) = Yrotated
\par   temp(cu, m% + 2) = Zrotated
\par  NEXT m%
\par NEXT cu
\par RETURN
\par '****************
\par 
\par ------------------------------ Source Code ---------------------------
\par 
\par Run this program, and you'll get a cube spinning around. Great. Actually, its missing one of its faces. God knows where it went, it got lost when I was copy pasting stuff around. Still, you won't notice till you add the solid fill bit. Try adding the missing face in your self, so you get used to how I've done it.
\par 
\par Now comes the polygon filler. I've set it up as a sub program where the two inputs are the ner() array, and a variable Poly, which is how many sides the polygon has.
\par 9This makes drawing shapes quick and simple, and can be called with the following line from any point.
\par 
\par                 DrawPolyGon (Ner(),Poly)
\par 
\par Anyway, heres a discripion of how it works.
\par You create an array that is as high as the screen, and three wide. Ie, on a 320*200, the array is 200*3. Every time you draw a new shape, this array is recreated, so that it is totaly empty.
\par 
\par In the program, the array is called StartStop(200, 0 to 2)
\par Where  StartStop(?,0) is the used/not used place
\par Where  StartStop(?,1) is the start place
\par Where  StartStop(?,0) is the Stop place
\par 
\par Then, we take the ner array, and break it down into a set of individual lines, just like the code that draws the outline of the shape. But instead of drawing lines between the start and stop positions, we move from one end of the line to the other, working out the horizontal position of each vertical point on the line. Okay, that don't make much sence, but look at this
\par 
\par We have a line going from 0,0 to 10,20 . The first number is the height.
\par 
\par The line moves 10 vertical units, and in that time, it has gone 20 units horizontaly
\par 
\par Therefore, every unit it goes up, it goes 20/10 (2) units horizontaly
\par 
\par So, what we do, is set a for next loop, that goes from the start vertical point to the end vertical point, so for this line it would be 0 to 10. We also set up a variable that equals the start horizontal point. I'll call it HORIZ for simplicity. Every time we go throught the for next loop, we add the horizontal value, remember that bit up there (2, 2 /10), to HORIZ
\par 
\par What it means is that as the for next loop moves from the start vertical height to the end vertical height, HORIZ moves from the value of the start horizontal value to the end horizontal value. Now, the last thing to do is store the values in the array. The value of N is the for next loop (or what ever the variable you used in the loop) it the height, and HORIZ is the width, so this is what you do.
\par 
\par First, look if you've already made a line at this height
\par 
\par IF startstop(n, 0) = 1 THEN
\par  'Yes, you'be been here before..
\par  startstop(n, 2) = HORIZ
\par  LINE (n, startstop(n, 1))-(n, startstop(n, 1))
\par ELSE
\par  'No, you havn't been here before
\par  startstop(n, 1) = HORIZ
\par  startstop(n, 0) = 1
\par END IF
\par 
\par Now, you hopfully understand the idea, heres the complete polygon filler, as a comlete sub program.
\par 
\par ------------------------------ Source Code ---------------------------
\par 
\par 
\par ------------------------------ Source Code ---------------------------
\par 
\par Add this sub program to the code before it, and remove the comment mark on the line that calls the sub program. You should now have a solid cube spinning around the screen! But somthing is wrong. The faces are being drawn in the wrong order. They should be drawn starting from the furthest to the closest to the viewer.
\par To do this, we'll need another array. Call it Order(100,2), which will be able sort 100 faces into order. The ordering process has 2 stages. First, we will go throught each face and work out the center Z value. Do do this, we add up all the Z values for each corner of the face, and devide the total by the number of corners. This value will go into Order(n,2). Order(n,1) will be the number of the face you are dealing with...
\par 
\par FOR n = 1 TO Number.Of.Faces
\par  FOR m = 1 TO Number.Of.Corners.On.Face.N
\par   ZValue = ZValue + Z.Value.Of.Corner.M
\par  NEXT m
\par  ZValue = ZValue / Number.Of.Corners.On.Face.N
\par  order(n, 2) = ZValue
\par  order(n, 1) = n
\par NEXT n
\par 
\par 
\par Now we have to sort the values in orer(?,2) into order, and when we move a number around in the second colomn of the order array, the number in the first colomn has to go with it, so we can draw the right faces... Observe>
\par 
\par 
\par Colomn 1   Colomn 2                        Colomn 1     Colomn2       
\par   
\par    1                 100                                   1               100 
\par    2                 300          Becomes          3               200
\par    3                 200                                   2               300 
\par 
\par 
\par See?
\par 
\par 
\par Now, to actually sort the numbers into order, I know two different methods.
\par One fast, and one slow.
\par 
\par The slow method, the bubble sort, works like this.
\par 
\par You look at the first number and the second number. If the first is bigger, you swap them over. Then you go to the second and third. If the second is bigger, you swap them over. Then you keep going till you get to the end of the list of numbers. Then, you do the whole thing again, the same number of times as the amount of numbers in the list. You can see why this is slow.
\par 
\par If you have 10 numbers,2 you have to 10 compares 10 times, Ie 100 compares. If you have 100 numbers, you have 100*100 , 10000 compares.
\par 
\par I won't give you the source code for a bubble sort, because the next method is better. I don't know if it has a name or what, its just faster.
\par 
\par What you do, is scan throught the list, looking for the smallest number, and remembering its position in the list. You then swap that number over with the first number. If the first number happens to be the smallest, you can just swap itself with itself, or ignore it. Same difference.
\par 
\par Now that you have the first number in order, you do the same with the second number. You don't have to look at position one, because position one is already in order
\par 
\par This is why its faster. On scan one, you start at position 1. On scan two, you start at position 2, you sort the last number, where you don't need to bother sorting anything, because its already in order. -->
\par 
\par If you have 4 numbers to sort, you'll do 4 compares, 3 on the second search, 2 on the third search, and you can ignore the last, so in total you'll have done 9 compares instead of the 16 that the bubble sort would have done. The quick sort is about twice as fast as the bubble sort.
\par 
\par Any way, heres the source code. Enjoy!
\par 
\par 
\par ------------------------------ Source Code ---------------------------
\par 
\par ? Wheres this code gone? Oops, I forgot to put it in. Silly me!
\par 
\par ------------------------------ Source Code ---------------------------
\par 
\par }
 